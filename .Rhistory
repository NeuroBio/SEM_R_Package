if(stat > P$MaxCtI || stat < P$MinCtI){
stop("stat must be in the min and max bounds of type")
}
}else if(type == "ChanceFor"){
if(P$ICtFN != 0){
P$ICtFN <- 0
warning("ICtFN reset to 0")
}
if(stat > P$MaxCtF || stat < P$MinCtF){
stop("stat must be in the min and max bounds of type")
}
}else{
stop("Unknown trait passed to invasion; Trait must be LrnThrsh, Acc, ChainceInv, or ChanceFor.")
}
return(P)
}
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 2, 30)
SEMSimulation(P, insultP=P, when=500, type="Insult", freq=1)
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 2, 30)
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 2, 30)
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 2, 30)
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 2, 30)
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 2, 30)
#create("SEM")
document()
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 2, 30)
InvasionSimulation(DefineParameters(), 4, "LrnThrsh", 47, 30)
system("R CMD Rd2pdf . --title=SEM --output=./manual.pdf --force --no-clean --internals")
#create("SEM")
document()
SEMSimulation(P, numInvader=4, type="Acc", stat=.99, when=20)
SEMSimulation(P, numInvader=4, type="Acc", stat=.99, when=20, type="Invasion")
#create("SEM")
document()
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
#create("SEM")
document()
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
#create("SEM")
document()
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
#' @family Sim Functions
#' @examples
#' P <- DefineParameters(RepSizePrefer = 0, MatchPrefer = 1, numSim=100)
#' SEMSimulation(P, 'Basic', 'Example', return=TRUE)
#' SEMSimulation(P, 'Interval', 'Example', return=TRUE, freq=2)
#'
#' P2 <- DefineParameters(numSim=600, MatchPrefer = 1, RepSizePrefer = 0)
#' P3 <- DefineParameters(numSim=600, SaveMatch = TRUE)
#' SEMSimulation(P2, insultP=P3, 'Insult', when=100, freq=2, save=FALSE, return = TRUE)
#' @export
SEMSimulation <- function(P, type='Basic', folderName=NA, save=TRUE, return=FALSE, verbose=TRUE, ...){
Time <- proc.time()
MiscArgs <- list(...)
if(is.na(P$Seed) == FALSE){
set.seed(P$Seed)
}
if(save){#Set up folder
if(is.na(folderName)){
folderName <- file.path(format(Sys.time(), "%F_%H-%M-%S"))
}
if(dir.exists(file.path(folderName)) == FALSE){
dir.create(file.path(folderName))
}
}
#Run Simulations
if(type == 'Basic'){
Data <- BasicSimulation(P, MiscArgs$freq)
}else if(type == 'Light'){
Data <- LightSimulation(P, MiscArgs$freq)
}else if(type == 'Insult'){
Data <- InsultSimulation(P, MiscArgs$insultP, MiscArgs$when, MiscArgs$freq)
}else if(type == 'Invasion'){
Data <- InsultSimulation(P, MiscArgs$numInvader, MiscArgs$trait, MiscArgs$stat, MiscArgs$when)
}else{
stop("Simulation type not recognized; check your spelling and case!")
}
if(save){#write the data
if(type == 'Invasion'){
write.csv(Data,file.path(folderName,'Invasion.csv'),row.names=FALSE)
}else{
eval(parse(text=paste0("write.csv(Data$",SaveInfo$Name,",file.path(folderName,'",
SaveInfo$Name, ".csv'),row.names=FALSE)")))
SaveParam(P, folderName, type="Basic")
}
}
#return a sense of satisfaction
if(verbose){
print("Simulation Completed!")
print(proc.time()-Time)
if(save){
print(paste("Saved to", folderName))
}
}
if(return){#return the sim data
return(Data)
}
}
#' Get Save Info
#'
#' Generates the information to form appropriate datastructures
#' @param P a list of parameters
#' @family Sim Functions
#' @keywords read-write-run
#' @export
GetSaveInfo <- function(P){
Params <- c(TRUE, P$SMat, P$SAcc, P$SLrn, P$SCtI, P$SCtF,
P$SNam, P$SNam, P$SAge, P$SMSng, P$SFSng)
Names <- c("SylRep", "Match", "Acc", "LrnThsh", "ChanceInv", "ChanceFor",
"Name", "FatherName", "Age", "MSong", "FSong")
SaveInfo <- data.frame(Name=Names, Has=Params,
Size=c(rep(P$numBirds,9), P$MaxRSize, P$MaxRSize),
Location=c(rep('Males',9), 'MSongs', 'FSongs'),
Sublocation=c(Names[1:9], NA, NA), stringsAsFactors = FALSE)
return(SaveInfo[SaveInfo$Has,])
}
#' Basic Simulation
#'
#' Runs a simulation where individual values are saved for every time step.  No parameters change during the simulation.
#' @param P a list of parameters
#' @param freq how often to sample data from the simulation
#' @family Sim Functions
#' @keywords read-write-run
#' @export
BasicSimulation <- function(P, freq=1){
if(is.null(freq)){
freq <- 1
}
SaveInfo <- GetSaveInfo(P)
Population <- GenerateFounderMales(P)
#Make Matricies and save initial data
eval(parse(text=paste0(SaveInfo$Name, "<-matrix(0,nrow=", SaveInfo$Size,
", ncol=", (P$nSim/freq)+1, ")")))
eval(parse(text=paste0(SaveInfo$Name,"[,", 1, "]<-",
ifelse(is.na(SaveInfo$Sublocation),
paste0("colSums(Population$", SaveInfo$Location, ")"),
paste0("Population$", SaveInfo$Location, "$", SaveInfo$Sublocation)))))
#Run the simulation
Counter <- 2
for(i in 2:(P$nSim+1)){
Population <- BirthDeathCycle(P, Population)
if(i%%freq == 0){#Save
eval(parse(text=paste0(SaveInfo$Name,"[,", Counter, "]<-",
ifelse(is.na(SaveInfo$Sublocation),
paste0("colSums(Population$", SaveInfo$Location, ")"),
paste0("Population$", SaveInfo$Location, "$", SaveInfo$Sublocation)))))
Counter <- Counter+1
}
P$SimStep <- i
}
eval(parse(text=paste0("Data <- list(", paste0(SaveInfo$Name, "=", SaveInfo$Name, collapse = ","), ")" )))
return(Data)
}
#' Light Simulation
#'
#' Runs a simulation where the only average values are saved every [freq] time step.  No parameters change during the simulation.
#' @param P a list of parameters
#' @param freq how often to sample data from the simulation
#' @family Sim Functions
#' @keywords read-write-run
#' @export
LightSimulation <- function(P, freq=200){
if(is.null(freq)){
freq <- 200
}
SaveInfo <- GetSaveInfo(P)
Population <- GenerateFounderMales(P)
#Make Matricies and save initial data
eval(parse(text=paste0(SaveInfo$Name, "<-matrix(0,nrow=",
ifelse(SaveInfo$Name %in% c("MSong", "FSong"), SaveInfo$Size, 1),
", ncol=", (P$nSim/freq)+1, ")")))
eval(parse(text=paste0(SaveInfo$Name,"[,", 1, "]<-",
ifelse(is.na(SaveInfo$Sublocation),
paste0("colSums(Population$", SaveInfo$Location, ")"),
paste0("mean(Population$", SaveInfo$Location, "$", SaveInfo$Sublocation, ")")))))
#Run the simulation
Counter <- 2
for(i in 2:(P$nSim+1)){
Population <- BirthDeathCycle(P, Population)
if(i%%freq == 0){#Save
eval(parse(text=paste0(SaveInfo$Name,"[,", Counter, "]<-",
ifelse(is.na(SaveInfo$Sublocation),
paste0("colSums(Population$", SaveInfo$Location, ")"),
paste0("mean(Population$", SaveInfo$Location, "$", SaveInfo$Sublocation, ")")))))
Counter <- Counter+1
}
P$SimStep <- i
}
eval(parse(text=paste0("Data <- list(", paste0(SaveInfo$Name, "=", SaveInfo$Name, collapse = ","), ")" )))
return(Data)
}
#'
#' Runs an invasion simulation where the time to conversion and final average value of the trait is returned.  [numInvader] invaders have their [trait] changed to [invaderStat] and their age reset to 1 time step [when].  Simulation ends when invaders are expelled, take over, or P$nSim time steps have passed.
#' @param P a list of parameters
#' @param numInvader the number of invaders to add
#' @param trait the stat to change: LrnThsh, Acc, ChanceInv, or ChanceFor
#' @param invaderStat the stat to change: LrnThsh, Acc, ChanceInv, or ChanceFor
#' @param when the time step at which to introduce the insult
#' @family Sim Functions
#' @keywords read-write-run
#' @export
InvasionSimulation <- function(P, numInvader, trait, stat, when){
P <- CheckInvasion(P, trait, stat)
Population <- GenerateFounderMales(P)
#Run simulation
for(i in 1:(when-1)){
#Complete a cycle
Population <- BirthDeathCycle(P, Population)
P$SimStep <- i
}
#Introduce invader(s)
Invaders <- sample(P$numBirds, numInvader)
Population$Males[Invaders, trait] <- stat
Population$Males[Invaders,'Age'] <- 1
for(i in 1:P$nSim){
Population <- BirthDeathCycle(P, Population)
if(length(unique(Population$Males[,trait]))== 1){
break
}
}
return(c(i, mean(Population$Males[,trait])))
}
#' Checks whether the noise for the [trait] was set to 0, and does so it not.  Also ensures that [stat] is within the range for the [trait]..
#' @param P a list of parameters
#' @param numInvader the number of invaders to add
#' @param trait the stat to change: LrnThsh, Acc, ChanceInv, or ChanceFor
#' @param invaderStat the stat to change: LrnThsh, Acc, ChanceInv, or ChanceFor
#' @param when the time step at which to introduce the insult
#' @param freq how often to sample data from the simulation
#' @family Sim Functions
#' @keywords read-write-run
#' @export
CheckInvasion <- function(P, trait, stat){
if(trait == "LrnThrsh"){
if(P$ILrnN != 0){
P$ILrnN <- 0
warning("ILrnN reset to 0")
}
if(stat > P$MaxLrn || stat < P$MinLrn){
stop("stat must be in the min and max bounds of trait")
}
}else if(trait == "Acc"){
if(P$IAccN != 0){
P$IAccN <- 0
warning("IAccN reset to 0")
}
if(stat > P$MaxAcc || stat < P$MinAcc){
stop("stat must be in the min and max bounds of trait")
}
}else if(trait == "ChanceInv"){
if(P$ICtIN != 0){
P$ICtIN <- 0
warning("ICtIN reset to 0")
}
if(stat > P$MaxCtI || stat < P$MinCtI){
stop("stat must be in the min and max bounds of trait")
}
}else if(trait == "ChanceFor"){
if(P$ICtFN != 0){
P$ICtFN <- 0
warning("ICtFN reset to 0")
}
if(stat > P$MaxCtF || stat < P$MinCtF){
stop("stat must be in the min and max bounds of trait")
}
}else{
stop("Unknown trait passed to invasion; Trait must be LrnThrsh, Acc, ChainceInv, or ChanceFor.")
}
return(P)
}
#' Insult Simulation
#'
#' Runs a simulation where the only average values are saved every [freq] time step.  Parameters change from P to insultP at time step [when].
#' @param P a list of parameters
#' @param insultP a list of parameters to switch to at time step [when]
#' @param when the time step at which to introduce the insult
#' @param freq how often to sample data from the simulation
#' @family Sim Functions
#' @keywords read-write-run
#' @export
InsultSimulation <- function(P, insultP, when, freq=200){
CheckInsultPs(P, insultP)
if(is.null(freq)){
freq <- 200
}
SaveInfo <- GetSaveInfo(P)
Population <- GenerateFounderMales(P)
#Make Matricies and save initial data
eval(parse(text=paste0(SaveInfo$Name, "<-matrix(0,nrow=",
ifelse(SaveInfo$Name %in% c("MSong", "FSong"), SaveInfo$Size, 1),
", ncol=", (P$nSim/freq)+1, ")")))
eval(parse(text=paste0(SaveInfo$Name,"[,", 1, "]<-",
ifelse(is.na(SaveInfo$Sublocation),
paste0("colSums(Population$", SaveInfo$Location, ")"),
paste0("mean(Population$", SaveInfo$Location, "$", SaveInfo$Sublocation, ")")))))
#Run simulation
Counter <- 2
for(i in 2:(P$nSim+1)){
if(i == when){#Introduce insult
#fix songs if needed
if( (P$Dial != insultP$Dial) ||
(P$UniMat != insultP$UniMat) ||
(insultP$MatPref != 0 && (exists('FSongs', where=Population) == FALSE)) ){
Population[["FSongs"]] <- CreateFemaleSongs(insultP)
Population$Males[["Match"]] <- TestMatch(P, Population$MSongs, Population$FSongs)
}
P <- insultP
}
#Complete a cycle and save data
Population <- BirthDeathCycle(P, Population)
if(i%%freq == 0){#Save
eval(parse(text=paste0(SaveInfo$Name,"[,", Counter, "]<-",
ifelse(is.na(SaveInfo$Sublocation),
paste0("colSums(Population$", SaveInfo$Location, ")"),
paste0("mean(Population$", SaveInfo$Location, "$", SaveInfo$Sublocation, ")")))))
Counter <- Counter+1
}
P$SimStep <- i
}
eval(parse(text=paste0("Data <- list(", paste0(SaveInfo$Name, "=", SaveInfo$Name, collapse = ","), ")" )))
return(Data)
}
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, type="Invasion")
InvasionData(P, numInvader=4, trait="Acc", stat=.99, when=20)
InvasionSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20)
#create("SEM")
document()
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
#' @family Sim Functions
#' @examples
#' P <- DefineParameters(RepSizePrefer = 0, MatchPrefer = 1, numSim=100)
#' SEMSimulation(P, 'Basic', 'Example', return=TRUE)
#' SEMSimulation(P, 'Interval', 'Example', return=TRUE, freq=2)
#'
#' P2 <- DefineParameters(numSim=600, MatchPrefer = 1, RepSizePrefer = 0)
#' P3 <- DefineParameters(numSim=600, SaveMatch = TRUE)
#' SEMSimulation(P2, insultP=P3, 'Insult', when=100, freq=2, save=FALSE, return = TRUE)
#' @export
SEMSimulation <- function(P, type='Basic', folderName=NA, save=TRUE, return=FALSE, verbose=TRUE, ...){
Time <- proc.time()
MiscArgs <- list(...)
if(is.na(P$Seed) == FALSE){
set.seed(P$Seed)
}
if(save){#Set up folder
if(is.na(folderName)){
folderName <- file.path(format(Sys.time(), "%F_%H-%M-%S"))
}
if(dir.exists(file.path(folderName)) == FALSE){
dir.create(file.path(folderName))
}
}
#Run Simulations
if(type == 'Basic'){
Data <- BasicSimulation(P, MiscArgs$freq)
}else if(type == 'Light'){
Data <- LightSimulation(P, MiscArgs$freq)
}else if(type == 'Insult'){
Data <- InsultSimulation(P, MiscArgs$insultP, MiscArgs$when, MiscArgs$freq)
}else if(type == 'Invasion'){
InvasionSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20)
#Data <- InsultSimulation(P, MiscArgs$numInvader, MiscArgs$trait, MiscArgs$stat, MiscArgs$when)
}else{
stop("Simulation type not recognized; check your spelling and case!")
}
if(save){#write the data
if(type == 'Invasion'){
write.csv(Data,file.path(folderName,'Invasion.csv'),row.names=FALSE)
}else{
eval(parse(text=paste0("write.csv(Data$",SaveInfo$Name,",file.path(folderName,'",
SaveInfo$Name, ".csv'),row.names=FALSE)")))
SaveParam(P, folderName, type="Basic")
}
}
#return a sense of satisfaction
if(verbose){
print("Simulation Completed!")
print(proc.time()-Time)
if(save){
print(paste("Saved to", folderName))
}
}
if(return){#return the sim data
return(Data)
}
}
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
#' @family Sim Functions
#' @examples
#' P <- DefineParameters(RepSizePrefer = 0, MatchPrefer = 1, numSim=100)
#' SEMSimulation(P, 'Basic', 'Example', return=TRUE)
#' SEMSimulation(P, 'Interval', 'Example', return=TRUE, freq=2)
#'
#' P2 <- DefineParameters(numSim=600, MatchPrefer = 1, RepSizePrefer = 0)
#' P3 <- DefineParameters(numSim=600, SaveMatch = TRUE)
#' SEMSimulation(P2, insultP=P3, 'Insult', when=100, freq=2, save=FALSE, return = TRUE)
#' @export
SEMSimulation <- function(P, type='Basic', folderName=NA, save=TRUE, return=FALSE, verbose=TRUE, ...){
Time <- proc.time()
MiscArgs <- list(...)
if(is.na(P$Seed) == FALSE){
set.seed(P$Seed)
}
if(save){#Set up folder
if(is.na(folderName)){
folderName <- file.path(format(Sys.time(), "%F_%H-%M-%S"))
}
if(dir.exists(file.path(folderName)) == FALSE){
dir.create(file.path(folderName))
}
}
#Run Simulations
if(type == 'Basic'){
Data <- BasicSimulation(P, MiscArgs$freq)
}else if(type == 'Light'){
Data <- LightSimulation(P, MiscArgs$freq)
}else if(type == 'Insult'){
Data <- InsultSimulation(P, MiscArgs$insultP, MiscArgs$when, MiscArgs$freq)
}else if(type == 'Invasion'){
InvasionSimulation(P, MiscArgs$numInvader, MiscArgs$trait, MiscArgs$stat, MiscArgs$when)
#Data <- InsultSimulation(P, )
}else{
stop("Simulation type not recognized; check your spelling and case!")
}
if(save){#write the data
if(type == 'Invasion'){
write.csv(Data,file.path(folderName,'Invasion.csv'),row.names=FALSE)
}else{
eval(parse(text=paste0("write.csv(Data$",SaveInfo$Name,",file.path(folderName,'",
SaveInfo$Name, ".csv'),row.names=FALSE)")))
SaveParam(P, folderName, type="Basic")
}
}
#return a sense of satisfaction
if(verbose){
print("Simulation Completed!")
print(proc.time()-Time)
if(save){
print(paste("Saved to", folderName))
}
}
if(return){#return the sim data
return(Data)
}
}
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
#' @family Sim Functions
#' @examples
#' P <- DefineParameters(RepSizePrefer = 0, MatchPrefer = 1, numSim=100)
#' SEMSimulation(P, 'Basic', 'Example', return=TRUE)
#' SEMSimulation(P, 'Interval', 'Example', return=TRUE, freq=2)
#'
#' P2 <- DefineParameters(numSim=600, MatchPrefer = 1, RepSizePrefer = 0)
#' P3 <- DefineParameters(numSim=600, SaveMatch = TRUE)
#' SEMSimulation(P2, insultP=P3, 'Insult', when=100, freq=2, save=FALSE, return = TRUE)
#' @export
SEMSimulation <- function(P, type='Basic', folderName=NA, save=TRUE, return=FALSE, verbose=TRUE, ...){
Time <- proc.time()
MiscArgs <- list(...)
if(is.na(P$Seed) == FALSE){
set.seed(P$Seed)
}
if(save){#Set up folder
if(is.na(folderName)){
folderName <- file.path(format(Sys.time(), "%F_%H-%M-%S"))
}
if(dir.exists(file.path(folderName)) == FALSE){
dir.create(file.path(folderName))
}
}
#Run Simulations
if(type == 'Basic'){
Data <- BasicSimulation(P, MiscArgs$freq)
}else if(type == 'Light'){
Data <- LightSimulation(P, MiscArgs$freq)
}else if(type == 'Insult'){
Data <- InsultSimulation(P, MiscArgs$insultP, MiscArgs$when, MiscArgs$freq)
}else if(type == 'Invasion'){
Data <- InvasionSimulation(P, MiscArgs$numInvader, MiscArgs$trait, MiscArgs$stat, MiscArgs$when)
}else{
stop("Simulation type not recognized; check your spelling and case!")
}
if(save){#write the data
if(type == 'Invasion'){
write.csv(Data,file.path(folderName,'Invasion.csv'),row.names=FALSE)
}else{
eval(parse(text=paste0("write.csv(Data$",SaveInfo$Name,",file.path(folderName,'",
SaveInfo$Name, ".csv'),row.names=FALSE)")))
SaveParam(P, folderName, type="Basic")
}
}
#return a sense of satisfaction
if(verbose){
print("Simulation Completed!")
print(proc.time()-Time)
if(save){
print(paste("Saved to", folderName))
}
}
if(return){#return the sim data
return(Data)
}
}
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion")
SEMSimulation(P, numInvader=4, trait="Acc", stat=.99, when=20, type="Invasion", return=TRUE, save=FALSE)
#dir.create("D:/Documents/R/SEM")
setwd("D:/Documents/R/SEM/SEM_R_Package")
#create("SEM")
document()
system("R CMD Rd2pdf . --title=SEM --output=./manual.pdf --force --no-clean --internals")
