?predict
SylRep
x <- data.frame(y=runif(10), x1=1:10, x2=11:20, x3=1:10)
Intercept <- 0.5
b1 <- 0.6
b2 <- 0.7
b3 <- 0.8
x$yTheo <- Intercept + b1*x$x1 + b2*x$x2 + b3*x$x3
x$resid <- x$y - x$yTheo
x
Data <- data.frame(y=, x=,)
Intercept <- 0.5
b <- 0.6
Intercept <- 0.5
b <- 0.6
Data$yTheo <- Intercept + b*x$x
Data$resid <- Data$y - Data$yTheo
Data
?regtest
library(metafor)
?regtest
#install.packages('devtools')
library('devtools')
install.packages('devtools', dependencies = TRUE)
#install.packages('devtools', dependencies = TRUE)
library('devtools')
install.packages('glue')
#install.packages('devtools', dependencies = TRUE)
library('devtools')
install_github("NeuroBio/SEM_R_Package", auth_token = '16c1be17177c16008499e5c1ba23ee590dfcf575', dependencies = TRUE)
library('SEM')
P <- DefineParameters()
setwd("D:/Documents/R/SEM/SEM_R_Package")
document()
#install.packages("devtools")
library("devtools")
#devtools::install_github("klutometis/roxygen")
library('roxygen2')
Packs <- c("mc2d", "numbers", "uuid")
for(i in Packs){
if(!eval(parse(text=paste0("require(",i,")")))){
install.packages(i)
}
eval(parse(text=paste0("library(",i,")")))
}
#dir.create("D:/Documents/R/SEM")
setwd("D:/Documents/R/SEM/SEM_R_Package")
document()
system("R CMD Rd2pdf . --title=SEM --output=./manual.pdf --force --no-clean --internals")
P <- DefineParameters(SaveMaleSong = TRUE, SaveFemaleSong = TRUE, SaveMatch = TRUE, SaveChancetoInvent = TRUE, SaveChancetoForget = TRUE, SaveNames = TRUE, SaveAge = TRUE, MatchPrefer = 1, RepSizePrefer = 0)
P
document()
P <- DefineParameters(SaveMaleSong = TRUE, SaveFemaleSong = TRUE, SaveMatch = TRUE, SaveChancetoInvent = TRUE, SaveChancetoForget = TRUE, SaveNames = TRUE, SaveAge = TRUE, MatchPrefer = 1, RepSizePrefer = 0)
P <- DefineParameters()
P
Length(P)
length(P)
P
as.vector(P)
as.character(P)
cbind(names(P),as.character(P))
document()
P <- DefineParameters()
cbind(names(P),as.character(P))
#' @param SaveChancetoForget whether to save the chance to forget; can be NA (the program decides based on other parameters) or TRUE/FALSE
#' @param SaveNames whether to save the UID and father's UID of the birds; can be TRUE or FALSE
#' @param SaveAge whether to save the age of the birds; can be TRUE or FALSE
#' @param SaveMaleSong whether to save male song templates; can be TRUE or FALSE
#' @param SaveFemaleSong whether to save female song templates; can be TRUE or FALSE
#' @param numSim the number of sim steps to complete
#' @param VerticalLearning whether the population undergoes vertical learning (TRUE) or not (FALSE)
#' @param Seed seed to run simulation on for reproducibility
#' @keywords initialize
#' @export
DefineParameters <- function(Rows=20, Cols=20, Steps=1,
InitialSylRepSize=5, PrcntSylOverhang=.2, MaxSylRepSize=500,
InitialAccuracy=.7, InherAccuracyNoise=.15,  AccuracyLimits=c(0,1),
MaxAge=20, InitialLearningThreshold=2, InherLearningNoise=.25, LearningLimits=c(0,MaxAge),
InitialChancetoInvent=.1, InherChancetoInventNoise=0, ChancetoInventLimits=c(0,1),
InitialChancetoForget=.2, InherChancetoForgetNoise=0, ChancetoForgetLimits=c(0,1),
ListeningThreshold=7, FatherListeningThreshold=.999, MinLearnedSyls=7,
EncounterSuccess=.95, LearningPenalty=.75, AgeDeath=TRUE,
PrcntRandomDeath=.1, DeathThreshold=1, ChickSurvival=.3,
LocalBreed=FALSE, LocalTutor=FALSE, LearnerStrategy="Add",
ConsensusNoTut=8, ConsensusStrategy="Conform",
OverLearn=FALSE, OverLearnNoTut=3, VerticalLearnCutOff=.25,
ObliqueLearning=TRUE, VerticalLearning=TRUE,
RepSizePrefer=1, LogScale=TRUE, MatchPrefer=0, UniformMatch=TRUE, MatchScale=1,
Dialects=1, MaleDialects="None", FemaleEvolve=FALSE, ChooseMate=FALSE,
SaveMatch=NA, SaveAccuracy=NA, SaveLearningThreshold=NA, SaveChancetoInvent=NA, SaveChancetoForget=NA,
SaveNames=FALSE, SaveAge=FALSE, SaveMaleSong=FALSE, SaveFemaleSong=FALSE,
numSim=1000, Seed=NA){
numBirds <- Rows*Cols
if(AgeDeath){
InitProp <- CalculateProportion(numBirds, DeathThreshold, ChickSurvival, MaxAge)
}else{
InitProp <- 0
}
if((LearnerStrategy %in% c("Add", "AddForget", "Forget", "Consensus")) == FALSE){
stop("LearnerStrategy must be either Add, Forget, AddForget, or Consensus.")
}
if(LearnerStrategy == "Consensus"){
Consensus=TRUE
Add=TRUE
Forget=TRUE
}else{
Consensus=FALSE
if(LearnerStrategy %in% c("Add", "AddForget")){
Add=TRUE
}else{Add=FALSE}
if(LearnerStrategy %in% c("AddForget", "Forget")){
Forget=TRUE
}else{Forget=FALSE}
}
#match the saves
SaveMatch <- TestRequirement(SaveMatch, MatchPrefer, FemaleEvolve)
SaveAccuracy <- TestRequirement(SaveAccuracy, InherAccuracyNoise)
SaveLearningThreshold <- TestRequirement(SaveLearningThreshold, InherLearningNoise)
SaveChancetoInvent <- TestRequirement(SaveChancetoInvent, InherChancetoInventNoise)
SaveChancetoForget <- TestRequirement(SaveChancetoForget, InherChancetoForgetNoise)
Parameters <- data.frame(R=Rows, C=Cols, numBirds=numBirds, Steps=Steps,
RSize0=InitialSylRepSize, PerROh=PrcntSylOverhang, MaxRSize=MaxSylRepSize,
Acc0=InitialAccuracy, IAccN=InherAccuracyNoise,
MinAcc=AccuracyLimits[1], MaxAcc=AccuracyLimits[2],
MAge=MaxAge, LrnThrsh0=InitialLearningThreshold, ILrnN=InherLearningNoise,
MinLrn=LearningLimits[1], MaxLrn=LearningLimits[2],
CtI0=InitialChancetoInvent, ICtIN=InherChancetoInventNoise,
MinCtI=ChancetoInventLimits[1], MaxCtI=ChancetoInventLimits[2],
CtF0=InitialChancetoForget, ICtFN=InherChancetoForgetNoise,
MinCtF=ChancetoForgetLimits[1], MaxCtF=ChancetoForgetLimits[2],
LisThrsh=ListeningThreshold, FLisThrsh=FatherListeningThreshold,
MinLrnSyl=MinLearnedSyls, EnSuc=EncounterSuccess,
Lpen=LearningPenalty, DStrat=AgeDeath, PDead=PrcntRandomDeath,
DeadThrsh=DeathThreshold, Pc=ChickSurvival, InitProp=InitProp,
ScopeB=LocalBreed, ScopeT=LocalTutor,
Consen=Consensus, ConsenS=ConsensusStrategy, Add=Add, Forget=Forget,
ConNoTut=ConsensusNoTut, OvrLrn=OverLearn, OLNoTut=OverLearnNoTut,
Obliq=ObliqueLearning, Vert=VerticalLearning,
VertLrnCut=VerticalLearnCutOff,
RepPref=RepSizePrefer, LogScl=LogScale, MatPref=MatchPrefer,
NoisePref=1-(RepSizePrefer + MatchPrefer), UniMat=UniformMatch, MScl=MatchScale,
Dial=Dialects, MDial=MaleDialects, FEvo=FemaleEvolve, ChoMate=ChooseMate,
SMat=SaveMatch, SAcc=SaveAccuracy, SLrn=SaveLearningThreshold,
SCtI=SaveChancetoInvent, SCtF=SaveChancetoForget, SNam=SaveNames,
SAge=SaveAge, SMSng=SaveMaleSong, SFSng=SaveFemaleSong,
SimStep=1, nSim=numSim, Seed=Seed, stringsAsFactors=FALSE)
P <- CheckP(Parameters)
return(Parameters)
}
P <- DefineParameters()
cbind(names(P),as.character(P))
SaveParam(P, "D:/Documents/R/AgentBasedModel/Comparison/")
CPath <- "D:/Documents/R/AgentBasedModel/Comparison/C/"
par(mfrow=c(2,4), mar=c(3,3,1,1), mgp=c(1.5,.5,0))
QuickPlot(P, file.path(dir, "Comparison"), AutoLayout = FALSE, Ty="l")
QuickPlotCSharp(P, CPath, AutoLayout = FALSE, Ty="l")
QuickSEMPlot(P, CPath, AutoLayout = FALSE, Ty="l")
QuickSEMPlot(P, CPath)
CPath
QuickSEMPlot(P, CPath, autoLayout=FALSE)
QuickSEMPlot(P, paste0(CPath, "Parameters", autoLayout=FALSE)
QuickSEMPlot(P, paste0(CPath, "Parameters"), autoLayout=FALSE)
QuickSEMPlot(P, paste0(CPath, "Parameters"), autoLayout=FALSE)
QuickSEMPlotC <- function(P, path, rep=TRUE, acc=P$SAcc, lrnThsh=P$SLrn, match=P$SMat,
chanceInv=P$SCtI, chanceFor=P$SCtF, age=P$SAge,
mSong=P$SMSng, fSong=P$SFSng, autoLayout=TRUE,
xlab="Time Steps", thin=10){
if(autoLayout == TRUE){#decide on plot configuration
NumPlot <- sum(rep, acc, lrnThsh, match, chanceInv,
chanceFor, age, mSong, fSong)
if(NumPlot == 1){
Config <- c(1,1)
}else if(NumPlot == 2){
Config <- c(2,1)
}else if(NumPlot %in% c(3,4)){
Config <- c(2,2)
}else if(NumPlot %in% c(5,6)){
Config <- c(3,2)
}else{Config <- c(3,3)}
par(mfrow=Config, mgp=c(2,.5,0), mar=c(3.2,3.3,1,1), las=1)
}
if(rep==TRUE){
SylRep <- read.csv(file.path(path,"ParametersSylRep.csv"))
TraitPlot(SylRep, xlab, ylab="Average Syllable Repertoire")
}
if(acc==TRUE){
Acc <- read.csv(file.path(path,"ParametersAcc.csv"))
TraitPlot(Acc, xlab, ylab="Average Accuracy")
}
if(lrnThsh==TRUE){
LrnThsh <- read.csv(file.path(path,"ParametersLrnThsh.csv"))
TraitPlot(LrnThsh, xlab, ylab="Average Learning Threshold")
}
if(match==TRUE){
Match <- read.csv(file.path(path,"ParametersMatch.csv"))
TraitPlot(Match, xlab, ylab="Average Match")
}
if(chanceInv==TRUE){
ChanceInv <- read.csv(file.path(path,"ParametersChanceInv.csv"))
TraitPlot(ChanceInv, xlab, ylab="Average Chance to Invent")
}
if(chanceFor==TRUE){
ChanceFor <- read.csv(file.path(path,"ParametersChanceFor.csv"))
TraitPlot(ChanceFor, xlab, ylab="Average Chance to Forget")
}
if(age==TRUE){
Age <- read.csv(file.path(path,"ParametersAge.csv"))
TraitPlot(Age, xlab, ylab="Average Age")
}
if(mSong==TRUE){
MSongs <- read.csv(file.path(path,"ParametersMSong.csv"))
SongPlot(P, MSongs, thin, TRUE)
}
if(fSong==TRUE){
FSongs <- read.csv(file.path(path,"ParametersFSong.csv"))
SongPlot(P, FSongs, thin, FALSE)
}
}
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
QuickSEMPlotC <- function(P, path, rep=TRUE, acc=P$SAcc, lrnThsh=P$SLrn, match=P$SMat,
chanceInv=P$SCtI, chanceFor=P$SCtF, age=P$SAge,
mSong=P$SMSng, fSong=P$SFSng, autoLayout=TRUE,
xlab="Time Steps", thin=10){
if(autoLayout == TRUE){#decide on plot configuration
NumPlot <- sum(rep, acc, lrnThsh, match, chanceInv,
chanceFor, age, mSong, fSong)
if(NumPlot == 1){
Config <- c(1,1)
}else if(NumPlot == 2){
Config <- c(2,1)
}else if(NumPlot %in% c(3,4)){
Config <- c(2,2)
}else if(NumPlot %in% c(5,6)){
Config <- c(3,2)
}else{Config <- c(3,3)}
par(mfrow=Config, mgp=c(2,.5,0), mar=c(3.2,3.3,1,1), las=1)
}
if(rep==TRUE){
SylRep <- read.csv(file.path(path,"ParametersSylRep.csv"))
TraitPlot(SylRep, xlab, ylab="Average Syllable Repertoire")
}
if(acc==TRUE){
Acc <- read.csv(file.path(path,"ParametersAcc.csv"))
TraitPlot(Acc, xlab, ylab="Average Accuracy")
}
if(lrnThsh==TRUE){
LrnThsh <- read.csv(file.path(path,"ParametersLrnThrsh.csv"))
TraitPlot(LrnThsh, xlab, ylab="Average Learning Threshold")
}
if(match==TRUE){
Match <- read.csv(file.path(path,"ParametersMatch.csv"))
TraitPlot(Match, xlab, ylab="Average Match")
}
if(chanceInv==TRUE){
ChanceInv <- read.csv(file.path(path,"ParametersChanceInv.csv"))
TraitPlot(ChanceInv, xlab, ylab="Average Chance to Invent")
}
if(chanceFor==TRUE){
ChanceFor <- read.csv(file.path(path,"ParametersChanceFor.csv"))
TraitPlot(ChanceFor, xlab, ylab="Average Chance to Forget")
}
if(age==TRUE){
Age <- read.csv(file.path(path,"ParametersAge.csv"))
TraitPlot(Age, xlab, ylab="Average Age")
}
if(mSong==TRUE){
MSongs <- read.csv(file.path(path,"ParametersMSong.csv"))
SongPlot(P, MSongs, thin, TRUE)
}
if(fSong==TRUE){
FSongs <- read.csv(file.path(path,"ParametersFSong.csv"))
SongPlot(P, FSongs, thin, FALSE)
}
}
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
path = CPath
if(autoLayout == TRUE){#decide on plot configuration
NumPlot <- sum(rep, acc, lrnThsh, match, chanceInv,
chanceFor, age, mSong, fSong)
if(NumPlot == 1){
Config <- c(1,1)
}else if(NumPlot == 2){
Config <- c(2,1)
}else if(NumPlot %in% c(3,4)){
Config <- c(2,2)
}else if(NumPlot %in% c(5,6)){
Config <- c(3,2)
}else{Config <- c(3,3)}
par(mfrow=Config, mgp=c(2,.5,0), mar=c(3.2,3.3,1,1), las=1)
}
SylRep <- read.csv(file.path(path,"ParametersSylRep.csv"))
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
QuickSEMPlotC <- function(P, path, rep=TRUE, acc=P$SAcc, lrnThsh=P$SLrn, match=P$SMat,
chanceInv=P$SCtI, chanceFor=P$SCtF, age=P$SAge,
mSong=P$SMSng, fSong=P$SFSng, autoLayout=TRUE,
xlab="Time Steps", thin=10){
if(autoLayout == TRUE){#decide on plot configuration
NumPlot <- sum(rep, acc, lrnThsh, match, chanceInv,
chanceFor, age, mSong, fSong)
if(NumPlot == 1){
Config <- c(1,1)
}else if(NumPlot == 2){
Config <- c(2,1)
}else if(NumPlot %in% c(3,4)){
Config <- c(2,2)
}else if(NumPlot %in% c(5,6)){
Config <- c(3,2)
}else{Config <- c(3,3)}
par(mfrow=Config, mgp=c(2,.5,0), mar=c(3.2,3.3,1,1), las=1)
}
if(rep==TRUE){
SylRep <- read.csv(file.path(path,"ParametersSylRep.csv"))
TraitPlot(t(SylRep), xlab, ylab="Average Syllable Repertoire")
}
if(acc==TRUE){
Acc <- read.csv(file.path(path,"ParametersAcc.csv"))
TraitPlot(t(Acc), xlab, ylab="Average Accuracy")
}
if(lrnThsh==TRUE){
LrnThsh <- read.csv(file.path(path,"ParametersLrnThrsh.csv"))
TraitPlot(t(LrnThsh), xlab, ylab="Average Learning Threshold")
}
if(match==TRUE){
Match <- read.csv(file.path(path,"ParametersMatch.csv"))
TraitPlot(t(Match), xlab, ylab="Average Match")
}
if(chanceInv==TRUE){
ChanceInv <- read.csv(file.path(path,"ParametersChanceInv.csv"))
TraitPlot(t(ChanceInv), xlab, ylab="Average Chance to Invent")
}
if(chanceFor==TRUE){
ChanceFor <- read.csv(file.path(path,"ParametersChanceFor.csv"))
TraitPlot(t(ChanceFor), xlab, ylab="Average Chance to Forget")
}
if(age==TRUE){
Age <- read.csv(file.path(path,"ParametersAge.csv"))
TraitPlot(t(Age), xlab, ylab="Average Age")
}
if(mSong==TRUE){
MSongs <- read.csv(file.path(path,"ParametersMSong.csv"))
SongPlot(P, MSongs, thin, TRUE)
}
if(fSong==TRUE){
FSongs <- read.csv(file.path(path,"ParametersFSong.csv"))
SongPlot(P, FSongs, thin, FALSE)
}
}
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
dev.off()
par(mfrow=c(2,4), mar=c(3,3,1,1), mgp=c(1.5,.5,0))
QuickSEMPlotC(P, paste0(CPath), autoLayout=FALSE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
QuickSEMPlotC(P, paste0(CPath), autoLayout=TRUE)
